//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include "Unit1.h"
#include "Unit2.h"
#include <vector>
#include <cmath>
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;

class GraphicElement {
	virtual void create(int x1, int y1, TImage *Image1) = 0;
	virtual void create(TImage *Image1) = 0;
};

class Segment : public GraphicElement{
	private:
		int x,y; // координаты первой точки отрезка
		int x1,y1; // координаты второй точки отрезка
		TColor color;
		int bold;
	public:
		Segment(TColor color, int bold, int x, int y, std::vector<int>&sequence){
		   this -> color = color;
		   this -> bold = bold;
		   this -> x = x;
		   this -> y = y;
		   this -> x1 = x;
		   this -> y1 = y;
		   sequence.emplace_back(1);
		}

		Segment(TColor color, int bold, int x, int y){
		   this -> color = color;
		   this -> bold = bold;
		   this -> x = x;
		   this -> y = y;
		   this -> x1 = x;
		   this -> y1 = y;
		}

		void create(int x1, int y1, TImage *Image1){
			this -> x1 = x1;
			this -> y1 = y1;
			Form1->Image1->Canvas->Pen->Style = psSolid;
			Form1->Image1->Canvas->Pen->Color = color;
			Form1->Image1->Canvas->Pen->Width = bold;
			Image1->Canvas->MoveTo(x,y); // рисую линию
			Image1->Canvas->LineTo(x1,y1);
		}

		void create(TImage *Image1){
			Form1->Image1->Canvas->Pen->Style = psSolid;
			Form1->Image1->Canvas->Pen->Color = color;
			Form1->Image1->Canvas->Pen->Width = bold;
			Image1->Canvas->MoveTo(x,y); // рисую линию
			Image1->Canvas->LineTo(x1,y1);
		}

};

class MyArc : public GraphicElement{
	private:
		TPoint points[3]; // массив точек для построения кривой Безье
		TColor color;
		int bold;

	public:
		MyArc(TColor color, int bold, int x, int y, std::vector<int>&sequence){
		   this -> color = color;
		   this -> bold = bold;
		   this -> points[0] = TPoint(x,y);
		   this -> points[1] = TPoint(x,y);
		   this -> points[2] = TPoint(x,y);
		   sequence.emplace_back(2);
		}

		MyArc(TColor color, int bold, int x, int y){
		   this -> color = color;
		   this -> bold = bold;
		   this -> points[0] = TPoint(x,y);
		   this -> points[1] = TPoint(x,y);
		   this -> points[2] = TPoint(x,y);
		}

		void create(int x1, int y1, TImage *Image1){
			this -> points[1] = TPoint(x1,y1);
			Form1->Image1->Canvas->Pen->Style = psSolid;
			Form1->Image1->Canvas->Pen->Color = color;
			Form1->Image1->Canvas->Pen->Width = bold;
			Image1->Canvas->MoveTo(points[0].x,points[0].y); //задание начальной точки
			Image1->Canvas->PolyBezierTo(points,2);//отрисовка точек

		}

		void create(int x1, int y1){
			this -> points[2] = TPoint(x1,y1);
			this -> points[1] = TPoint(x1,y1);
		}

		void create(TImage *Image1){
			Form1->Image1->Canvas->Pen->Style = psSolid;
			Form1->Image1->Canvas->Pen->Color = color;
			Form1->Image1->Canvas->Pen->Width = bold;
			Image1->Canvas->MoveTo(points[0].x,points[0].y); //задание начальной точки
			Image1->Canvas->PolyBezierTo(points,2);//отрисовка точек
		}

};

//-------Demo-------------
class MyPolyline : public GraphicElement{
	private:
		std::vector<Segment> segments;
		std::vector<MyArc> arcs;
		std::vector<int> sequenceP; // 1-отрезок, 2-дуга // отвечает за последовательность рисования элементов в полилинии
		int s;
		int i = -1; //индекс для вектора элементов
		int a = -1;
	   //	int x1, y1;  // где закончилось последнее построение
		TColor color;
		int bold;
	public:
		MyPolyline(TColor color, int bold, int x, int y, int sequenceP, std::vector<int>&sequence){
		   this -> s = sequenceP;
		   if(sequenceP == 1) {
			  segments.emplace_back(Segment(color, bold, x, y));
			  this -> sequenceP.emplace_back(1);
			  i++;
		   }
		   if(sequenceP == 2) {
			  arcs.emplace_back(MyArc(color, bold, x, y));
			  this -> sequenceP.emplace_back(2);
			  a++;
		   }
		   sequence.emplace_back(3);
		}

		void create(TColor color, int bold, int x, int y, int sequenceP){

            this -> s = sequenceP;
		   if(sequenceP == 1) {
			  segments.emplace_back(Segment(color, bold, x, y));
			  this -> sequenceP.emplace_back(1);
			  i++;
		   }
		   if(sequenceP == 2) {
			  arcs.emplace_back(MyArc(color, bold, x, y));
			  this -> sequenceP.emplace_back(2);
			  a++;
		   }
		}

		void create(int x1, int y1, TImage *Image1){

		   if(s == 1) {
			  segments.at(i).create(x1,y1,Image1);
		   }
		   if(s == 2) {
			  arcs.at(a).create(x1,y1,Image1);
		   }
		}

		void create(int x1, int y1){
		   if(s == 2) {
			  arcs.at(a).create(x1,y1);
		   }
		}

		void create(TImage *Image1){
           int i = 0, a = 0;
		   for(int t : sequenceP){
			   if(t==1){
					Segment segment = segments.at(i);
					segment.create(Image1);
					i++;
			   }
			   if(t==2) {
					MyArc myarc = arcs.at(a);
					myarc.create(Image1);
					a++;
			   }
		   }
		}

};

/*
//-----Demo----------------

//------Demo---------------
/*class Polyline : public GraphicElement{
	private:
		Segment segment;
		std::vector<Segment> segments;
		Arc arc;
		std::vector<Arc> arcs;
		std::vector<int> sequence; // 1-отрезок, 2-дуга // отвечает за последовательность рисования элементов в полилинии

	public:
		Polyline(TColor color, int bold, int x, int y, int element){
		   if(element == 1){
				this -> segments.emplace_back(Segment(color, bold, x, y));
				this -> segments.emplace_back(1);
		   }
		   if(element == 2){
				this -> arcs.emplace_back(Arc(color, bold, x, y));
				this -> arcs.emplace_back(2);
		   }
		}

		void create(int x1, int y1, TImage *Image1, int element){
			this -> x1 = x1;
			this -> y1 = y1;
			Form1->Image1->Canvas->Pen->Style = psSolid;
			Form1->Image1->Canvas->Pen->Color = color;
			Form1->Image1->Canvas->Pen->Width = bold;
			Image1->Canvas->MoveTo(x,y); // рисую линию
			Image1->Canvas->LineTo(x1,y1);
		}

		void create(TImage *Image1){
			Form1->Image1->Canvas->Pen->Style = psSolid;
			Form1->Image1->Canvas->Pen->Color = color;
			Form1->Image1->Canvas->Pen->Width = bold;
			Image1->Canvas->MoveTo(x,y); // рисую линию
			Image1->Canvas->LineTo(x1,y1);
		}

}; */
//------------------------------------

void redrawing(const std::vector<Segment>&segments,const std::vector<MyArc>&arcs,const std::vector<MyPolyline>&polylines,const std::vector<int>&sequence, TImage *Image1, String fileName){

	if(fileName != ""){
		Image1->Picture->LoadFromFile(fileName);
	}
	else{
		Form1->Image1->Canvas->Brush->Color=clWhite; // заливаю все белым
		Form1->Image1->Canvas->Pen->Style=psSolid;
		Form1->Image1->Canvas->Pen->Width = 1;
		Form1->Image1->Canvas->Pen->Color = clWindowFrame;
		Form1->Image1->Canvas->Rectangle(0,0,Form1->Image1->Width, Form1->Image1->Height);
	}

	int i = 0, a = 0, p = 0;
	for(int t : sequence){
		 if(t==1){
			Segment segment = segments.at(i);
			segment.create(Image1);
			i++;
		 }
		 if(t==2) {
			MyArc myarc = arcs.at(a);
			myarc.create(Image1);
			a++;
		 }
		 if(t==3) {
			MyPolyline mypl = polylines.at(p);
			mypl.create(Image1);
			p++;
		 }
	}
	/*for(Segment n : segments) //перерисовка отрезков
		n.create(Image1);*/
}

void vectors_cleaning(std::vector<Segment>&segments){
   segments.clear();

  // for(auto i = segments.begin(); i != segments.end(); segments.erase(i));
}

std::vector<Segment> segments;
std::vector<MyArc> arcs;
std::vector<MyPolyline> polylines;
std::vector<int> sequence; // порядок элементов 1 - отрезокб 2 -дуга
TColor color; // активный цвет
int bold = 1; // активная толщина
int i = -1; // текущий индекс для вектора отрезков
int a = -1; // текущий индекс для вектора дуг
int p = -1; // текущий индекс для вектора полилиний
int point=0; // первая или вторая точка отрезка
int x,y; //начальная точка отрезка
bool save = false; // показывает сохранен ли уже файл
String fileName = "";
int seg_arc = 1;
int x2=0, y2=0; //конец предыдущего сегмента полилинии и начало нового
//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
	: TForm(Owner)
{
	Form1->Image1->Width = 0;
	Form1->Image1->Height = 0;

	SpeedButton1 -> GroupIndex = 1;
	SpeedButton1 -> Down = true;
	SpeedButton2 -> GroupIndex = 1;
	SpeedButton2 -> Down = false;
	SpeedButton3 -> GroupIndex = 1;
	SpeedButton3 -> Down = false;
	SpeedButton4 -> GroupIndex = 1;
	SpeedButton4 -> Down = false;
	SpeedButton5 -> GroupIndex = 1;
	SpeedButton5 -> Down = false;
	SpeedButton6 -> GroupIndex = 1;
	SpeedButton6 -> Down = false;
	SpeedButton7 -> GroupIndex = 1;
	SpeedButton7 -> Down = false;
	SpeedButton8 -> GroupIndex = 1;
	SpeedButton8 -> Down = false;
	ComboBox1->ItemIndex = 0;
    FlowPanel2-> Visible = false;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::New1Click(TObject *Sender)
{
  int k;
	if(Form1->Save1->Enabled == true){
	   Application->NormalizeTopMosts();
	   #ifdef _DELPHI_STRING_UNICODE
	   k = Application->MessageBox(L"Сохранить текущее изображение?", L"PlyPaint Сохранение", MB_YESNOCANCEL);
	   #else
	   k = Application->MessageBox("Сохранить текущее изображение?", "PlyPaint Сохранение", MB_YESNOCANCEL);
	   #endif
	   Application->RestoreTopMosts();

		if(k == 6){
			SavePictureDialog1->DefaultExt=".bmp";
			SavePictureDialog1->Filter="Bitmaps (*.bmp)|*.bmp";
			if (SavePictureDialog1->Execute()){
				Image1->Picture->Bitmap->SaveToFile(SavePictureDialog1->FileName);
			}
			Form2->Show();
			Form1->Enabled = false;
		}
		if(k == 7) {
			Form2->Show();
			Form1->Enabled = false;
		}
	}
	else{
		Form2->Show();
		Form1->Enabled = false;
		vectors_cleaning(segments);   i=-1;
	}

	save = false;
	fileName = "";
}
//---------------------------------------------------------------------------
void __fastcall TForm1::FormResize(TObject *Sender)
{
	Form1-> ScrollBox1 -> Width = Form1 -> Width-55; //-20
	Form1-> ScrollBox1 -> Height = Form1 -> Height-80; //-80
	Form1-> FlowPanel1 -> Height = Form1 -> Height-81;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Image1MouseMove(TObject *Sender, TShiftState Shift, int X,
          int Y)
{
	Label3 -> Caption = X;
	Label4 -> Caption = Y;

	//----отрезок--------
	if(SpeedButton3 -> Down == true){
	 if(point == 1){
		redrawing(segments,arcs,polylines,sequence,Image1,fileName); // перерисовываем все элементы
		segments.at(i).create(X,Y,Image1); // дорисовываем новый отрезок
	 }
	}
	//----отрезок end----

    //----дуга--------
	if(SpeedButton6 -> Down == true){
		if(point == 1){
			redrawing(segments,arcs,polylines,sequence,Image1,fileName);
			arcs.at(a).create(X,Y);
		}
		if(point == 2){
			redrawing(segments,arcs,polylines,sequence,Image1,fileName);
			arcs.at(a).create(X,Y,Image1);
		}
	}
	//----отрезок end----

	//----полилиния--------
	if(SpeedButton4 -> Down == true){

		if(point == 1){
		  redrawing(segments,arcs,polylines,sequence,Image1,fileName);
		  if(seg_arc == 1){
			 polylines.at(p).create(X,Y,Image1);
		  }
		  if(seg_arc == 2){
			 polylines.at(p).create(X,Y);
		  }

		}

		if(point == 2){
			redrawing(segments,arcs,polylines,sequence,Image1,fileName);
			polylines.at(p).create(X,Y,Image1);
		}

	}
	//----полилиния end----
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Image1MouseLeave(TObject *Sender)
{
	Label3 -> Caption = "";
	Label4 -> Caption = "";
}
//---------------------------------------------------------------------------
void __fastcall TForm1::SaveAs1Click(TObject *Sender)
{
	SavePictureDialog1->DefaultExt=".bmp";
	SavePictureDialog1->Filter="Bitmaps (*.bmp)|*.bmp";
	if (SavePictureDialog1->Execute()){
		Image1->Picture->Bitmap->SaveToFile(SavePictureDialog1->FileName);
	}
	//Form1->Save1->Enabled = true;
	Form1->Close1->Enabled = true;
	save = true;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Close1Click(TObject *Sender)
{
   int k;
	if(Form1->Save1->Enabled == true){
	   Application->NormalizeTopMosts();
	   #ifdef _DELPHI_STRING_UNICODE
	   k = Application->MessageBox(L"Сохранить текущее изображение?", L"PlyPaint Сохранение", MB_YESNOCANCEL);
	   #else
	   k = Application->MessageBox("Сохранить текущее изображение?", "PlyPaint Сохранение", MB_YESNOCANCEL);
	   #endif
	   Application->RestoreTopMosts();

		if(k == 6){
			SavePictureDialog1->DefaultExt=".bmp";
			SavePictureDialog1->Filter="Bitmaps (*.bmp)|*.bmp";
			if (SavePictureDialog1->Execute()){
				Image1->Picture->Bitmap->SaveToFile(SavePictureDialog1->FileName);
			}
			Form1->Image1->Picture->Bitmap->FreeImage();
			Form1->Image1->Picture->Bitmap = NULL;
			Form1->Image1->Width = 0;
			Form1->Image1->Height = 0;
			Form1->Save1->Enabled = false;
			Form1->SaveAs1->Enabled = false;
			Form1->Close1->Enabled = false;
		}
		if(k == 7) {
			Form1->Image1->Picture->Bitmap->FreeImage();
			Form1->Image1->Picture->Bitmap = NULL;
			Form1->Image1->Width = 0;
			Form1->Image1->Height = 0;
			Form1->Save1->Enabled = false;
			Form1->SaveAs1->Enabled = false;
			Form1->Close1->Enabled = false;
		}
	}
	else{
		Form1->Image1->Picture->Bitmap->FreeImage();
		Form1->Image1->Picture->Bitmap = NULL;
		Form1->Image1->Width = 0;
		Form1->Image1->Height = 0;
		Form1->Save1->Enabled = false;
		Form1->SaveAs1->Enabled = false;
		Form1->Close1->Enabled = false;
		vectors_cleaning(segments);   i=-1;
        save = false;
		fileName = "";
	}

}
//---------------------------------------------------------------------------
void __fastcall TForm1::Save1Click(TObject *Sender)
{
	Image1->Picture->Bitmap->SaveToFile(SavePictureDialog1->FileName);
	Form1->Save1->Enabled = false;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Open1Click(TObject *Sender)
{
	int k;
	if(Form1->Save1->Enabled == true){
	   Application->NormalizeTopMosts();
	   #ifdef _DELPHI_STRING_UNICODE
	   k = Application->MessageBox(L"Сохранить текущее изображение?", L"PlyPaint Сохранение", MB_YESNOCANCEL);
	   #else
	   k = Application->MessageBox("Сохранить текущее изображение?", "PlyPaint Сохранение", MB_YESNOCANCEL);
	   #endif
	   Application->RestoreTopMosts();

		if(k == 6){
			SavePictureDialog1->DefaultExt=".bmp";
			SavePictureDialog1->Filter="Bitmaps (*.bmp)|*.bmp";
			if (SavePictureDialog1->Execute()){
				Image1->Picture->Bitmap->SaveToFile(SavePictureDialog1->FileName);
			}
			if(OpenPictureDialog1->Execute()){
			   Image1->Picture->LoadFromFile(OpenPictureDialog1->FileName);
			}
			Form1->Enabled = true;
			Form1->SaveAs1->Enabled = true;
			Form1->Close1->Enabled = true;
		}
		if(k == 7) {
			if(OpenPictureDialog1->Execute()){
				Image1->Picture->LoadFromFile(OpenPictureDialog1->FileName);
			}
			Form1->Enabled = true;
			Form1->SaveAs1->Enabled = true;
			Form1->Close1->Enabled = true;
		}
	}
	else{
		if(OpenPictureDialog1->Execute()){
			fileName = OpenPictureDialog1->FileName;
			Image1->Picture->LoadFromFile(fileName);
		}
		Form1->Enabled = true;
		Form1->SaveAs1->Enabled = true;
		Form1->Close1->Enabled = true;
		vectors_cleaning(segments);   i=-1;
	}

}
//---------------------------------------------------------------------------




void __fastcall TForm1::Image1MouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift,
		  int X, int Y)
{
	//----отрезок--------
	if(SpeedButton3 -> Down == true){
		if(point == 0){
			point = 1;
			i++;
			segments.emplace_back(Segment(color, bold, X, Y,sequence));
		}

		else if(point == 1){
			point = 0;
			redrawing(segments,arcs,polylines,sequence,Image1,fileName);
		}

		if(save == true)
			Form1->Save1->Enabled = true;
	}
	//----отрезок end----

	//----дуга--------
	if(SpeedButton6 -> Down == true){
		if(point == 0){
			point = 1;
			a++;
			arcs.emplace_back(MyArc(color, bold, X, Y, sequence));
		}

		else if(point == 1){
			point = 2;
			redrawing(segments,arcs,polylines,sequence,Image1,fileName);
			arcs.at(a).create(X,Y);
		}

		else if(point == 2){
			point = 0;
			redrawing(segments,arcs,polylines,sequence,Image1,fileName);
		}

		if(save == true)
			Form1->Save1->Enabled = true;
	}
	//----отрезок end----

	//----полилиния--------
	if(SpeedButton4 -> Down == true){
		if(SpeedButton9 -> Down == true) seg_arc = 1;
		if(SpeedButton10 -> Down == true) seg_arc = 2;
		if(point == 0){
			point = 1;
			p++;
			polylines.emplace_back(MyPolyline(color, bold, X, Y, seg_arc, sequence));
		}


	   /*	else if(point == -1){
			//redrawing(segments,arcs,polylines,sequence,Image1,fileName);
			polylines.at(p).create(color, bold, x2,  y2, seg_arc);
			//redrawing(segments,arcs,polylines,sequence,Image1,fileName);
			point = 1;
		}*/

		else if(point == 1){

		  if(seg_arc ==2){
			point = 2;
			redrawing(segments,arcs,polylines,sequence,Image1,fileName);
			polylines.at(p).create(X,Y,Image1);
		  }
		  else if( seg_arc == 1){
			//point = -1;
			redrawing(segments,arcs,polylines,sequence,Image1,fileName);
			polylines.at(p).create(color, bold, X,  Y, seg_arc);
		  }

		  x2 = X;
		  y2 = Y;
		}

		else if(point == 2){
			point = 1;
			redrawing(segments,arcs,polylines,sequence,Image1,fileName);
		   //	polylines.at(p).create(color, bold, X,  Y, seg_arc);
		   polylines.at(p).create(X,  Y, Image1);
			polylines.at(p).create(color, bold, x2,  y2, seg_arc);
		}

		if(save == true)
			Form1->Save1->Enabled = true;

        if ( Button == mbRight )
		{
			point = 0;
			redrawing(segments,arcs,polylines,sequence,Image1,fileName);
		}
	}

	//----полилиния end----
}
//---------------------------------------------------------------------------

void __fastcall TForm1::Panel2Click(TObject *Sender)
{
	ColorDialog1->Execute();
	color = ColorDialog1->Color;
	Panel2 -> Color = color;
}
//---------------------------------------------------------------------------

void __fastcall TForm1::SpeedButton3Click(TObject *Sender)
{
	FlowPanel2->Visible = true;
}
//---------------------------------------------------------------------------

void __fastcall TForm1::FlowPanel2MouseDown(TObject *Sender, TMouseButton Button,
          TShiftState Shift, int X, int Y)
{
	const int SC_DRAGMOVE=61458;

	ReleaseCapture();
	((TControl *)Sender)->Perform(WM_SYSCOMMAND,SC_DRAGMOVE,0);
}
//---------------------------------------------------------------------------

void __fastcall TForm1::ComboBox1Change(TObject *Sender)
{
	if(ComboBox1->ItemIndex == 0) bold = 1;
	if(ComboBox1->ItemIndex == 1) bold = 3;
	if(ComboBox1->ItemIndex == 2) bold = 5;
	if(ComboBox1->ItemIndex == 3) bold = 7;
	if(ComboBox1->ItemIndex == 4) bold = 9;
	if(ComboBox1->ItemIndex == 5) bold = 11;
	if(ComboBox1->ItemIndex == 6) bold = 13;
	if(ComboBox1->ItemIndex == 7) bold = 15;
	if(ComboBox1->ItemIndex == 8) bold = 17;
	if(ComboBox1->ItemIndex == 9) bold = 20;
	if(ComboBox1->ItemIndex == 10) bold = 23;
	if(ComboBox1->ItemIndex == 11) bold = 25;
	if(ComboBox1->ItemIndex == 12) bold = 27;
	if(ComboBox1->ItemIndex == 13) bold = 30;
	if(ComboBox1->ItemIndex == 14) bold = 35;
	if(ComboBox1->ItemIndex == 15) bold = 40;
	if(ComboBox1->ItemIndex == 16) bold = 45;
	if(ComboBox1->ItemIndex == 17) bold = 50;
	if(ComboBox1->ItemIndex == 18) bold = 55;
	if(ComboBox1->ItemIndex == 19) bold = 60;
	if(ComboBox1->ItemIndex == 20) bold = 65;
	if(ComboBox1->ItemIndex == 21) bold = 70;
	if(ComboBox1->ItemIndex == 22) bold = 80;
	if(ComboBox1->ItemIndex == 23) bold = 90;
	if(ComboBox1->ItemIndex == 24) bold = 100;
}
//---------------------------------------------------------------------------

void __fastcall TForm1::SpeedButton6Click(TObject *Sender)
{
	FlowPanel2->Visible = true;

}
//---------------------------------------------------------------------------






